SPRING DATA

SEMPLIFICA L ACCESSO AI DATI FORNENDO UN INTERFACCIA UNIFICATA E UTILIZZA LO STANDARD JPA JAVA PERSISTANCE API, SPRING DATA E IN GRADO DI INTERAGIRE CON QUALUNQUE DB (SQL E NOSQL)

CONCETTO CHIAVE E IL REPOSITORY, CHE PUO ESSERE ASSOCIATO A QUALSIASI ENTITATA DI DATI. JPAREPOSITORY E LE SIE SOTTOCLASSI E LA TIPIZZAZIONE DI REPOSITORY CHE USEREMO, CHE CI PERMETTERA DI SCRIVERE CODICE SOLO QUANDO E NECESSARIO(CONVENTION OVER CONFIGURATION)

JPA E UNA LIBRERIA CHE INTRODUCE LA JPQL JAVA PERSISTANCE QUERY LANGUAGE, UN ASTRAZIONE CHE PERMETTE DI FARE QUERY SU UN DB TRAMITE IL MODELLO DELL ENTITA CORRISPONDENTE, SENZA SCRIVERLA IN SQL.
JPA E UN INSIME DI INTERFACCE COSI CHE NON ESISTONO VERE E PROPRIE IMPLEMENTAZIONI, QUESTE SARANNO DATE DALLA LIBRERIA HIBERNATECHE FORNISCE UN ORM.
LA CONNESSIONE CON JDBC ( JAVA DB CONNECTION) SARA FATTA IN AUTOMATICO GRAZIE AD UNA SEMPLICE DIPENDENZA
JPA PERCIO NON E UNA IMPLEMENTAZIONE CONCRETA, MA UNA SPECIFICA
HIBERNATE E UN IMPLEMENTAZIONE CHE SEGUE LE SPECIFICHE DI JPA

ORM OBJECT RELATIONAL MAPPER SERVE PER LA GESTIONE DELLA PERSISTENZA DEI DATI NEL DB ATTRAVERSO GLI OGGETTI. L ORM MAPPA GLI ATTRIBUTI DELL OGGETTO CON LE COLONNE DELLA TABELLA UNA VOLTA CHE ABBIAMO DETTO AL MODELLO QUALE TABELLA E LA SUA CORRISPONDENTE, SE SI MANTIENE LA STESSA NOMENCLATURA E POSSIBILE CHE ORM RIESCA A CONVERTIRE IL MODELLO CON LA TABELLA CORRISPONDENTE.

PROGETTO BLOG CON UN DATABASE CEH SEGUE IL DIAGRAMMA ENTITY RELATIONSHIP DIAGRAM (EER): RAPPRESENTA L ENTITA DEL SISTEMA E LE LORO RELAZIONI TRA LORO

CREA PROGETTO
SPRING INITIALIZER  CREATE MAVEN
ULTIMA VERSIONE NON SNAPSHOT
JAVA
GRPUP ID (IT.AULAB)
NOME PACCHETTO
JAR
VERSIONE JAVA
DIPENDENZE NECESSARIE (JPA SPRING DATA, MYSQL DRIVER, SPRING BOOT DEVTOOLS, SPRING WEB)
SALVA NEL FOLDER E OPEN DALLA NOTIFICA

CREO DATABASE MYSQL
LO COLLEGO CON MYSQLTOOLS(SOTTO EXTENSION, TEST,..)
MYSQL.. DEVO DARE UN NOME A PIACERE E POI SCRIVERE ESATTAMENT QUELLO DEL DATABASE

CREO FOLDER .SQL E IN QUETSA
-CREATE.SQL E QUI POSSO SCRIVERE CODICE IN MYSQL PER LA CREAZIONE DELLE TABELLE
-RUNNO PER VEDERE SE CI SONO ERRORI
-DROP.SQL E FACCIO DROP TABLE PER OGNI TAB IN ORDINE DI SVINCOLO DELLE CHIAVI(PRIMA L ULTIMA)

APPLICATION PROPERTIES 
QUI AGGIUNGO LE CONFIGURAZIONI PER CREARE IL JDBC TEMPLATE, JPA USA IL JDBC TEMPLATE MA DOBBIAMO CREARLO: CONNECTION STRING, DRIVER, USERNAME, PASSWORD

spring.datasource.url=jdbc:mysql://localhost:3306/springBlogDatabase
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

ADESSO IL PROGETTO E REALMENTE COLLEGATO AL DATABASE

ENTITY MANAGER: INTERFACCIA NECESSARIA CHE INTERAGISCE CON IL MODELLO(ENTITA) DEI DATI.
NEI MODELLI DEFINIAMO LE CARATTERISTICHE DEFLI OGGETTI CHE SARANNO RIFLESSE NELLE TAB DEL DB, AGGIUNGENDO FUNZ UTILI COME LE RELAZIONI TRA I MODELLI STESSI.
AUTHORS AVRA UNA RELAZIONE 1TOMANY CON POSTS E QUANDO DICHIAREREMO IL MODELLO AUTORE DAREMO UNA PROPRIETA POSTS CHE RESTITUIRA I POST DELL AUTORE, GRAZIE ALLE ANOOTATION.
L ENTITY MANAGER PERMETTE DI ESEGUIRE OPERAZIONI SULLA PERSISTENZA DEI DATI (CRUD).

USEREMO HIBERNATE COME IMPLEMENTAZIONE DEL JPA

MODELS FOLDER
CREIAMO AUTHOR : @ENTITY INDICA ALLA JPA CHE QUESTA CLASSE HA UNA TABELLA DI RIFERIMENTO NEL DB, @TABLE(NAME = "AUTHORS") NOME DELLA TABELLA NECESSARIO!!

DEFINIAMO ATTRIBUTI

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
GENERATED VALUE PERMETTE DI DIRE CHE IL VALORE IN DB DI QUESTO SARA GENERATO DALLA JPA E CON LA STRATEGY GLI DICIAMO IN CHE MODO(IDENTITY PER ID, AUTO IL FW LO DEDUCE, SEQUENCE CREA UNA SEQUENZA, UUID ID ESADECIMALE)

CREO UN ATTRIBUTO PER OGNI COLONNA DELLA TAB
SE IL NOME DELL ATTRIBUTO E UGAULE ALLA COLONNA NON CE BISOGNO DI DIRE NULLA, SE GLI ATTRIBUTI SONO DIVERSI CON LA COLONNA DOBBIAMO INSERIRE UNA SPECIFICA ANNOTATION @COLUMN 
CON QUESTA ANNOTATION POSSIAMO DEFINIRE NUOVE PROPRIETA COME POTER SPECIFICARE SE E NULLABLE O UNIQUE

@Column(name = "firstname", nullable = true)
private String name;
@Column(name = "lastname", nullable = true)
private String surname;
@Column(nullable = false, unique = true)
private String email;

EMAIL NON PUO ESSERE NULL E DEVE ESSERE UNICO

COMPLETA CON GETTER E SETTER E UN COSTR VUOTO

CREO POST

@Entity
@Table(name = "posts")
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String title;
    @Column(nullable = false, length = 100)
    private String body;
    @Column(nullable = true, length = 8)
    private String publishDate;

}

PUBLISHDATE IN DB E PUBLISH_DATE MA VA BENE COMUNQUE
QUI DOBBIAMO AGGIUNGERE LA RELAZIONE CON LA TAB AUTHORS (CLASSE AUTHOR)

@ManyToOne
@Column(name = "author_id")
private Author author;

GETTER SETTER E COSTRUTTORE VUOTO

CREO COMMENT

@Column(nullable = false, length = 100)
    private String title;
    @Column(nullable = false, length = 200)
    private String body;
    @Column(nullable = true, length = 8)
    private String publishDate;

    @ManyToOne
    @JoinColumn(name="post_id", nullable = false)
    private Post post;

GETTER E SETTER


ADESSO DA UN AUTORE VOGLIO ACCEDERE AI SUOI POST E DAI POST AI SUOI COMMENTI

in author
@OneToMany(mappedBy = "author")
private List<Post> posts = new ArrayList<Post>();

SARA UNA LISTA DI POST, MAPPERDBY SI RIFERISCE A QUALE ATTRIBUTI STA ACENDO IL COLLEGAMENTO(L ATTRIBUTO DELLA CLASSE POST MANY TO ONE AUTHOR)
CREAIAMO UN ARRAYLIST VOUTO COSI CHE IN CASO DI DROP NON ABBIAMO NULL

UGUALE IN POST
@OneToMany(mappedBy = "post")
    private List<Comment> comments = new ArrayList<Comment>();


GETTER E SETTER SEMPRE

ONE TO MANY E MANY TO MANY HANNO I PARAMETRI PERCHE COSI QUANDO SI FA LA QUERY SI FA LA QUERY DI TUTTE LE RISORSE DISPONIBILE, RICHIAMANDO ANCHE L OGETTO NELLA CLASSE COLLEGATA

MINUTO 31









