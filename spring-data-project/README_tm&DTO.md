THYMELEAF

CLIENT SIDE RENDERING: QUANDO IL CLIENT FA RICHIESTA AL SERVER, SI RICHIEDE UNA RISORSA STATICA(PAG HTML), IL CLIENT IN BASE A QUELLO CHE RICEVE SE GLI SERVE ALTRO FA RICHIESTE ALLE DIVERSE RISORSE, ESEMPIO AI SERVER ESTERNI CON LE CDN(BOOTSTRAP) O ALTRE AL SERVER STESSO PER ES RISORSE JS. IL CLIENT UNA VOLTA RICEVUTA L HTML RENDERIZZA IN BASE ALLA SUE NECESSITA, ANCHE SOLO APPLICARE IL CSS

SERVER SIDE RENDERING: USA IL TEMP ENGINE, VENGONO UTILIZZATI DEI LINGUAGGI CHE IS INTEGRANO NELL HTML ED ELABORANO I COMPONENTI DELLA PAGINA, APPLICHIAMOLO: SCRVIAMO LA PAG HTML E COME OUTPUT UNA PAGINA NEL LINGUAGGIO CHE IL CLINET COMPRENDE

THYMELEAF: MOTORE TEMPLATE PER LA CREAZIONE DI PAG WEB IN JAVA E HTML: UTILIZZATO PER LA GENEAZIONE DINAMICA DI PAGINE WEB.

NEL POM AGGIUNGIAMO LA DIPENDENZA DI THYMELEAF
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

IN STATIC ABBAOMO TUTTE LE RISORSE STATICE DEL WEB SERVER, OSSIA CHE NON DEVONO ESSERE ELABORATE DAL SERVER, IL SERVER NON ESEGUE IL RENDERING LATO SERVER, MA SI AFFIDA AL CLIENT SIDE RENDERING PER QUESTE RISORSE STATICHE

CREA FILE INDEX.HTML METIIAMO STARTER TEMPLATE BOOTSTRAP
AVVIO RUN E APRO LOCALHOST8080
QUI AGGIUNGO VOLENDO CSS E JS

CREO PRIMO TEMPLATE PER GLI AUTORI, IN TEMPLATES ( POSSO FARE ANCHE SOTTO CARTELLE PER ORDINE)

NEL TEMPLATE BASE DEVO AGGIUNGERE SOPRA HEAD:
<html xmlns:th="https://www.thymeleaf.org">
IL NAMESPACE DI TH

AD ES : <title th:text="${title}"></title>
OGNI TAG COLLEGATO A THYMELEAF AVRA QUESTO ATTRIBUTO TH:, OSSIA PER TUTTI I TAG DINAMICI CHE DIPENDONO DA TH
th:text="${title}" E LA SINTASSI CON CUI INDICHEREMO A TH COSA DEVE DINAMIZZARE
TH:TEXT INDICA CHE IL TIPO DI DATO DA ELABORARE SARA UN TESTO

I CONTROLLER CHE GESTIRANNO I TEMPLATE SARANNO WEB, NON REST(CHE SERIALIZZANO I DATI SOLO IN FORMATO JSON)
I CONTROLLER WEB INTERCETTANO LE RICHIESTE HTTP MA RESTITUISCONO UNA VISTA, LI NOMINIAMO SOLO CONTROLLER, SENZA WEB, sia nell annotation che ne.

@Controller
@RequestMapping("/authors")
public class AuthorController {

    @GetMapping
    public String index(Model viewModel) {
        viewModel.addAttribute("title", "Auhtors")
        return "authors";
    }
}

GLI HANDLER DEVO SEMPLICEMENTE RICHIAMARE UNA STRINGA CON IL NOME DEL FILE IN TEMPLATES TELATIVO ALLA VISTA

il parametro model(importando UI) servira per passare i dati dal client al server
il viuewmodel e una map chiave valore, per aggiunger attributi alla mappa usiamo addattribute("chiave", "Authors")
la chiave sara il nome che mettiamo nell attributo html ${chiave}, il valore sara cio che ritorna la vista

QUESTA E L APPLICAZIONE DEL SERVER SIDE RENDERING

PER MOSTRARE DATI NEL TEMPLATE, COME TUTTI GLI AUTORI, DOBBIAMO INIETTARE IL SERVICE NEL CONTROLLER WEB, COSI CHE LO RICHIAMA, E POI COLLEGARE GLI ATTRIBUTI

<div class="container">
        <div class="row justify-content-center">
            <div th:each="author:${authors}" class="col-12 col-md-4">
                <p th:text="${author.id}"></p>
                <p th:text="${author.name}"></p>
            </div>
        </div>
    </div>
CON TH:EACH FACCIO UN CICLO FOR, CICLO AUTHORS CHE E COLLEGATO ALL HANDLER
POI ESTRAGGO ID E NAME NEI P, TH VERIFICA SE L ATTRIBUTO E PUBLIC E IN QUEL CASO LO RITORNA DIRETTMWNRE, SNENO CERCA IL SUO GETTER

TUTTO CIO VIENE GENERATO NEL BE, CON IL ENGINE, NIENTE VIENE FATTO IN JS (FE)

CREARE NUOVO DATO CON TH
CREO UN NUOVO HTML DINAMICO IN TEMPLATES CREATEAUTHORS DOVE INSERISCO UN FORM PER LA CREAZIONE
<div class="container">
        <div class="row">
            <div class="col-12 my-5 d-flex justify-content align-items-center">
                <h2 class="text-center">Aggiungi autore</h2>
            </div>
            <div class="col-12 my-5">
                <form th:action="@(/authors)" method="POST">

                </form>
            </div>
        </div>
    </div>

NEL FORM SPEFICIFICHIAMO CON ACTION LA ROTTA DEL CONTROLLER WEB DOVE AGIRA IL FORM E IL SUO METODO  "@(/AUTHORS)"

NEL CONTROLLER DOBBIAMO CREARE UN HANDLER DI TIPO GET CHE RESTIUISCE LA VISTA, E UNO POST CHE PERMETTERE DI CREARE L AUTORE
@GetMapping("create")
    public String createAuthorView(Model viewModel) {
        viewModel.addAttribute("title", "Create Author");
        viewModel.addAttribute("author", new Author());
        return "createAuthors";
    }
QUESTO HANDLER UTILIZZA IL SOLITO PARAMETRO MODEL PER DINAMIZZARE I DATI NELLA VISTA, RITORNA LA NUOVA VISTA
NELL ATTRIBUTO DI CREAZIONE RITORNERA UN NUOVO OGGETTO VUOTO DI AUTHOR CHE IL FORM UTILIZZERA PE RINIZIALIZZARE GLI INPUT PER POI PASSARLO AL HANDLER POST CHE LO SALVERA 


NEL TEMPLATE INSERIAMO UN FORM PER LA CREAZIONE
AGGIUNGIAMO UN ATTRIBUTO NEL FORM TH:OBJECT="${AUTHOR}" QUESTO SERVE PER SPECIFICARE LA CHIAVE DELL OGGETTO CHE ABBIAMO STABILITO NELL HANDLER PER IL NUOVO AUTORE, OSSIA QUELLO CHE AL SUBMIT VERRA RICHIAMATO
GLI ATTRIBUTI DELLA CLASSE HANNO UN ATTRIBUTO TH:FIELD="*{NAME} CHE DEVE ESSERE UGUALE PER MAPPARE GLI INPUT CON GLI ATTRIBUTI DEL NUOVO OGGETTO

<div class="col-12">
                <a th:href="@{/authors}">torna alla home</a>
            </div>
qui creo un button per tornare alla home

<div class="col-12">
            <a th:href="@{/authors/create}">aggiungiiiiiii</a>
        </div>
questo invece va alla create

PER FAR FUNZIONARE IL FORM COMPLETO L HANDLER POST
@PostMapping
    public String createAuthor(@ModelAttribute("author") Author author) {
        authorService.create(author);
        return "redirect:/authors";
    }
RITORNERA UN REDIRECT ALLA HOME AUTHORS, SMEOPRE VERSO ROTTE GET PERCHE LE POST NON HANNO TEMPLATE(LE REDIRECT SONO GESTITE DA UN DISPATCHER SERVLET, CHE CAPISCE CHE LA STRINGA SI RIFERISCE AD UN TEMPLATE, SE CI FOSSE STATO @REQUESTBODY NELLA FIRMA DEL METODO IL DISPATCHER NON RESTITUISCE UN TEMPLATE MA INSERIREBBE IL CONTENUTO NEL CORPO DELLA REQUEST )
GLI DEVO PASSARE IL MODEL ATTRIBUTE CHE HO DEFINITO NEL GET PASSANDO IL NUOVO OGGETTO


DTO DATA TRANSFER OBJECT
FINORA ABBIAMO USATO I DAO(DATA ACCESS OBJECT) NEI REPO PER COMUNICARE CON IL DATABASE
I DTO SONO OGGETTI CHE VENGONO UTILIZZATI PER TRASFERIRE DATI TRA I DIVERSI LIV, SE ABBIAMO BISOGNO DI RAPPRESENTARE DEGLI OGGETTI CHE SONO NEL DB ALL INTERNO DEI CONTROLLER USEREMO I DTO (NEL CONTROLLER)
DIFFERISCONO IN ALCUNI CASI DALLA VERE RAPPRESENTAZIONI DEGLI OGGETTI CHE SONO I DAO E POI TRAMITE CONVERSIONI VENGONO TRASFORMATI IN DAO
SONO DETI DATA TRANSFER PERCHE TRASFERISCONO CIO CHE VIENE RAPPRESENTATO DAI DAO SULL HTTP

SONO DIVERSI QUANDO AD ESEMPIO NEL CONTROLLER VENGONO MANIPOLATI DATI CHE NON RISPONDO ALLE TABELLE DEL DB, DOBBIAMO FARE UN OPERAZIONE DI CONVERSIONE DA DTO A DAO O IN PIU DAO
QUESTO AVVIENE PER CREARE UN INTERFACCIA PIU SEMPLICE RISPETTO ALLA MOLE DI DATI CHE VENGONO UTILIZZATI, COSI CHE IL FE ABBIA CONOSCENZA SOLO IN MODO COMPLESSIVO DEI DATI SENZA CHE SAPPIA DEL LORO UTILIZZO O MEMORIZZAZIONE

LIBRERIA MODELMAPPER
<dependency>
			<groupId>org.modelmapper</groupId>
			<artifactId>modelmapper</artifactId>
			<version>3.2.0</version>
		</dependency>
CONFIGURARE BEAN PER MAPPARE all interno della classe run perche questa ha l annotaione configuration gia compresa

@Bean
	public ModelMapper instanceModelMapper() {
		ModelMapper mapper = new ModelMapper();
		return mapper;
	}

questo sara singleton e sara vivo sempre nell nostro applicativo
INITTARLA IN SERVICE

ADESSO CREO UNA CLASSE AUTHORDTO CHE E UN POJO E HA GLI ATTRIBUTI CLASSCI

PER MAPPARE ADESSO DOBBIAMO MODIFICARE NEL SERVICE IL TIPO DI RITORNO DA AUTHOR A AUTHORDTO

modificare anche tutti i return, dobbiamo gestire il metodo map di mapper con l iniziezione che abbiamo fatto 
@Autowired
    private ModelMapper mapper;


ALLORAAAAAAAA IMPAZZISCOOOOO

PRATICAMENTE BISOGNA MODIFICARE LA LOGICA DEI SERVICE CHE PRIMA AGIVANO SUI DAO E ADESSO INVECE SUI DTO

SIGNIFICA CHE INTANTO I CONTROLLER RESTITUISCONO SEMORE DEI DTO, E I SERVICE UGUALE 
I SERVICE A QUESTO PUNTO GESTIRANNO SIA LA LOGICA DI ELABORAZIONE DEI DATI, CHE LA CONVCERSIONE IN DAO CHE VERRANO OPASSATI ALLA REPO... CHE RICEVONO DTO E MAGICAMENTE INTERAGISCONO COL DB RISPOONDENDO DEI DAO

NEI SERVICE PERCIO OLTRE ALLE ELABORAZIONE DELLA RICHIESTA VA MAPPATO IL DTO IN DAO
QUESTO AVVIENE COL METODO MAP DELLA LIBRERIA MAPPER, DOVE VA SPECIFICATO COME PRIMO VALORE IL DAO PRESO DAL REPOSITORY CON I METODI CHE SAPPIAMO E IL SECONDO SARA LA CLASSE CHE DEFINISCE I DTO, OERCIO LA CLASSE CONFIG CHE CREAIAMO PER CREARE I DAO.

