SPRING WEB

UTILE PER SVILUPPARE APPLICAZIONI WEB DI TIPO WEB SERVICES RESTFUL, FA PARTE DI SPRING MVC E CI PERMETTE DI:
-GESTIRE LE RICHIESTE HTTP
-MAPPARE URL A METODI JAVA CON ANNOTATION LEGATI AI METODI HTTP
-CREARE APIREST IN MODO SEMPLICE
-GESTIRE INPUT E OUTPUT IN FORMATO JSON O XML

ADESSO POSSIAMO COMUNICARE TRA BACKEND E FRONTEND


ARCHITETTURA CLIENT-SERVER: CLIENT(BROWSER) FA RICHIESTE E IL SERVER GLI RISPONDE
BE E FE PER COMUNICARE HANNO BISOGNO DI SEGUIRE UN PROTOCOLLO, OSSIA DELLE REGOLE PER CUI DUE ENTITA COMUNICANO FRA LORO: ATTRAVERSO IL BROWER CHHIEDIAMO AL SERVER RISORSE DI UN SITO, QUESTO SITO E HOSTATO IN UN SERVER CHE PUO ESSERE SITUATO OVUNQUE; IL PROTOCOLLO E HTTP
HTTP FA COMUNICARE DUE MACCHINE ED E IL PROTOCOLLO DEL MODELLO ISO/OSI, LO STACK SU CUI E BASATO IL WEB, A LIVELLO TEORICO; A LIVELLO PRATICO HTTP E IL PROTOCOLLO DEL MODELLO TCP/IP.

ATTRAVERSO L URL FACCIAMO UNA RICHIESTA A QUELL INDIRIZZO SPECIFICO, L INDIRIZZO VERO E PROPRIO E UN INDIRIZZO IP COMPOSTO DA NUMERI; NOI USIAMO UN DOMINIO NOMINALE CHE SARA TRADOTTO NELL IP GRAZIE AL DNS( DOMAIN NAME SYSTEM): IL BROWER CARICA LE RISORSE WEB CON L INDIRIZZO IP.
HTTP://LOCALHOST:8080

URL (UNIFORM RESOURCE LOCATOR) E LO SCHEMA DI IDENTIFICAZIONE, DI RINTRACCIABILITA, DEI CONTENUTI E SERVIZI WEB: PROTOCOLLO://DOMINIO3LIV.DOMINIO2LIV.DOMINIO1LIV/URI?QUERYSTRING#ELEMENTOHTML

DATI E SERVIZI CHE POSSONO ESSERE RESTITUITI DA UN URL:
-RISORSE STATICHE: IMG, FILE CSS, JS, FILE MULTIMEDIALI...
-SERVIZI/API: URL ASSOCIATO A UN SERVIZIO O UN API(APPLICATION PROGRAMMING INTERFACE): INSIEME DI ENDPOINT CON CUI IL CLIENT PUO INTERAGIRE CON IL BE PER OTTENERE DATI O INVIARNE
-CONTENUTI DINAMICI: IL SERVER ELABORA LA RICHIESTA DEL CLIENT, ACCEDE AL DB E GENERE UNA RISPOSTA.

IN URL SI PUO ANCHE UTILIZZARE UN URI: UNA STRINGA UNIVOCA PER UNA RISORSA WEB(ES LA HOME E /), CON ESSI RICHIAMEREMO I CONTROLLER

METODI HTTP CON CUI IL CLIENT EFFETTUA LE RICHIESTE: GET, POST, PUT, PATCH(MODIFICHE PARZIALI), DELETE.

MESSAGGI DI RISPOSTA IN BASE AL RISULTATO DELLA RICHIESTA:
1XX: MESSAGGI INFORMATIVI
2XX: SUCCESSO
3XX: REDIRECT (NON CE UNA RISPOSTA MA VIENE DETTO COME OTTENERLA)
4XX: CLIENT ERROR
5XX: SERVER ERROR

CONTROLLER API: RESPONSABILI DELLA GESTIONE DELLE RICHIESTE HTTP(RESTFUL O SOAP) CHE AVVENGONO TRAMITE API, RESTITUENDO DATI .JSON O .XML

CONTROLLER WEB: GENERANO E RESTITUISCONO PAGINE HTML DINAMICHE UTILAZZANDO THYMELEAF AD ES, COSI CHE IL BE COMPONE HTML PRIMA DI RISPONDERE

JSON E IL FORMATO PIU DIFFUSO PER INVIARE DATI: INSIEME DI COPPIE CHIAVE VALORE

PROTOCOLLO REST(REPRESENTIONAL STATE TRANSFER): E UN ARCHITETTURA PER LA PROGETTAZIONE DI SISTEMI DI COMUNICAZIONE, LE RICHIESTE REST SONO:
-STATELESS: SENZA MEMORIA, TUTTE LE INFO DEVONO ESSERE NELLA RICHIESTA PERCHE IL SERVER NON MANTIENE ALCUNA INFO
-IDENTIFICATO GRAZIE ALL URI E RAPPRESENTATI IN FORMATI .JSON O .XML
-POSSIAMO EFFETTUARE OPERAZIONI CRUD

API RESTFUL: E UN API BASATA SU REST, UN INTERFACCIA CHE SEGUE I PRINCIPI REST PER PROGETTARE SERVIZI WEB



SVILUPPO PROGETTO

CREO FOLDER CONTROLLERS DOVE CREERO UN CONTROLLER PER OGNI CLASSE(COME I REPO)
FAREMO TUTTO NEL CONTROLLER, SENZA SVILUPPARE L INTERFACCIA

@Controller
public class AuthorController {

    @Autowired
    AuthorRepository authorRepository;

    public @ResponseBody List<Author> getAllAuthors() {
        return authorRepository.findAll();
    }
}


ABBIAMO CREATO U METODO CHE RESTITUISCE UNA LIST DI AUTORI, UTILIZZANDO IL REPOSITORY:
@AUTOWIRED E AUTHORREPOSITORY REPOSITORY

@controller PER IDENTIFICARLA COME BEAN(STEREOTYPE)
@responsebody indica che il valore restituito deve essere considerato come il corpo della risposta http E NON COME UNA VISTA DA RISOLVERE.
USIAMO UN METODO FINDALL DELL INTERFACCIA CRUDREPOSITORY, QUESTO PERO RESTITUISCE UN ITERABLE CHE NON E CONVERTIBILE IN UNA LISTA, ALLORA DOVREMO UTILIZZARE UNA NUOVA INTERFACCIA LISTCRUDREPOSITORY CHE HA IL METODO FINDALL, QUESTA E UNA NUOVA INTERFACCIA CHE SPECIALIZZA I REPO PER LE LIST(SOSTITUIRE TUTTI I REPO AFFINCHE ESTENDANO LISTCRUDREPOSITORY)


I CONTROLLER GESTISCONO RICHIESTE CLIENT, COSI CHE E NECESSARIA UNA NUOVA ANNOTATION:
    @RequestMapping(value = "/authors", method = RequestMethod.GET)

MAPPA LE RICHIESTE HTTP VERSO METODI SPECIFICI, INDICHIAMO A PRING QUALE METODO DEVE ESSERE ESEGUITO IN BASE ALLA RICHIESTA RICEVUTO SU UN URL ATTRAVERSO UN URI SPECIFICO(URI,METODO): FUNZIONE HANDLER, PRIMO METODO API.

PUO ESSERE APPLICATA A LIVELLO DI CLASSE O DI METODO

CREO SCRIPT DI INSERIMENTO IN SQL PER TESTARE IL METODO GET APPENA CREATO
in folder .sql CREO INSERT.SQL CON DUE AUTORI

INSERT INTO authors (firstname, lastname, email)
value ("lollo", "micio", "lollo@micio.it");

INSERT INTO authors (firstname, lastname, email)
value ("fofo", "ciotti", "fofo@ciotti.it");

ESEGUO CON RUN ON ACTIVE

ADESSO PROVIAMO AD AVVIARE L APPLICAZIONE, RUNNO LA CLASSE APPLICATION
SI AVVIERA IL TOMCAT, IL FLUSSO ADESSO E IN MANO AI CONTROLLER

ADESSO CHE L APPLICAZIONE E RUNNATA HO MODO DI VEDERE UN INTERFACCIA SUL MIO LOCALHOST INPOSTATO, LA PORTA LA VEDO DA TERMINALE
http://localhost:8080/authors


MINUTO 24










