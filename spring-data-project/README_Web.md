SPRING WEB

UTILE PER SVILUPPARE APPLICAZIONI WEB DI TIPO WEB SERVICES RESTFUL, FA PARTE DI SPRING MVC E CI PERMETTE DI:
-GESTIRE LE RICHIESTE HTTP
-MAPPARE URL A METODI JAVA CON ANNOTATION LEGATI AI METODI HTTP
-CREARE APIREST IN MODO SEMPLICE
-GESTIRE INPUT E OUTPUT IN FORMATO JSON O XML

ADESSO POSSIAMO COMUNICARE TRA BACKEND E FRONTEND


ARCHITETTURA CLIENT-SERVER: CLIENT(BROWSER) FA RICHIESTE E IL SERVER GLI RISPONDE
BE E FE PER COMUNICARE HANNO BISOGNO DI SEGUIRE UN PROTOCOLLO, OSSIA DELLE REGOLE PER CUI DUE ENTITA COMUNICANO FRA LORO: ATTRAVERSO IL BROWER CHHIEDIAMO AL SERVER RISORSE DI UN SITO, QUESTO SITO E HOSTATO IN UN SERVER CHE PUO ESSERE SITUATO OVUNQUE; IL PROTOCOLLO E HTTP
HTTP FA COMUNICARE DUE MACCHINE ED E IL PROTOCOLLO DEL MODELLO ISO/OSI, LO STACK SU CUI E BASATO IL WEB, A LIVELLO TEORICO; A LIVELLO PRATICO HTTP E IL PROTOCOLLO DEL MODELLO TCP/IP.

ATTRAVERSO L URL FACCIAMO UNA RICHIESTA A QUELL INDIRIZZO SPECIFICO, L INDIRIZZO VERO E PROPRIO E UN INDIRIZZO IP COMPOSTO DA NUMERI; NOI USIAMO UN DOMINIO NOMINALE CHE SARA TRADOTTO NELL IP GRAZIE AL DNS( DOMAIN NAME SYSTEM): IL BROWER CARICA LE RISORSE WEB CON L INDIRIZZO IP.
HTTP://LOCALHOST:8080

URL (UNIFORM RESOURCE LOCATOR) E LO SCHEMA DI IDENTIFICAZIONE, DI RINTRACCIABILITA, DEI CONTENUTI E SERVIZI WEB: PROTOCOLLO://DOMINIO3LIV.DOMINIO2LIV.DOMINIO1LIV/URI?QUERYSTRING#ELEMENTOHTML

DATI E SERVIZI CHE POSSONO ESSERE RESTITUITI DA UN URL:
-RISORSE STATICHE: IMG, FILE CSS, JS, FILE MULTIMEDIALI...
-SERVIZI/API: URL ASSOCIATO A UN SERVIZIO O UN API(APPLICATION PROGRAMMING INTERFACE):API E UN INSIEME DI ENDPOINT CON CUI IL CLIENT PUO INTERAGIRE CON IL BE PER OTTENERE DATI O INVIARNE
-CONTENUTI DINAMICI: IL SERVER ELABORA LA RICHIESTA DEL CLIENT, ACCEDE AL DB E GENERE UNA RISPOSTA.

IN URL SI PUO ANCHE UTILIZZARE UN URI: UNA STRINGA UNIVOCA PER UNA RISORSA WEB(ES LA HOME E /), CON ESSI RICHIAMEREMO I CONTROLLER

METODI HTTP CON CUI IL CLIENT EFFETTUA LE RICHIESTE: GET, POST, PUT, PATCH(MODIFICHE PARZIALI), DELETE.

MESSAGGI DI RISPOSTA IN BASE AL RISULTATO DELLA RICHIESTA:
1XX: MESSAGGI INFORMATIVI
2XX: SUCCESSO
3XX: REDIRECT (NON CE UNA RISPOSTA MA VIENE DETTO COME OTTENERLA)
4XX: CLIENT ERROR
5XX: SERVER ERROR

CONTROLLER API: RESPONSABILI DELLA GESTIONE DELLE RICHIESTE HTTP(RESTFUL O SOAP) CHE AVVENGONO TRAMITE API, RESTITUENDO DATI .JSON O .XML

CONTROLLER WEB: GENERANO E RESTITUISCONO PAGINE HTML DINAMICHE UTILAZZANDO THYMELEAF AD ES, COSI CHE IL BE COMPONE HTML PRIMA DI RISPONDERE

JSON E IL FORMATO PIU DIFFUSO PER INVIARE DATI: INSIEME DI COPPIE CHIAVE VALORE

PROTOCOLLO REST(REPRESENTIONAL STATE TRANSFER): E UN ARCHITETTURA PER LA PROGETTAZIONE DI SISTEMI DI COMUNICAZIONE, LE RICHIESTE REST SONO:
-STATELESS: SENZA MEMORIA, TUTTE LE INFO DEVONO ESSERE NELLA RICHIESTA PERCHE IL SERVER NON MANTIENE ALCUNA INFO
-IDENTIFICATO GRAZIE ALL URI E RAPPRESENTATI IN FORMATI .JSON O .XML
-POSSIAMO EFFETTUARE OPERAZIONI CRUD

API RESTFUL: E UN API BASATA SU REST, UN INTERFACCIA CHE SEGUE I PRINCIPI REST PER PROGETTARE SERVIZI WEB



SVILUPPO PROGETTO

CREO FOLDER CONTROLLERS DOVE CREERO UN CONTROLLER PER OGNI CLASSE(COME I REPO)
FAREMO TUTTO NEL CONTROLLER, SENZA SVILUPPARE L INTERFACCIA

@Controller
public class AuthorController {

    @Autowired
    AuthorRepository authorRepository;

    public @ResponseBody List<Author> getAllAuthors() {
        return authorRepository.findAll();
    }
}

PS NON STIAMO UTILAZZANDO LA LOGICA DEI SERVICE PERCHE NON CI SERVE MANIPOLARE PARTICOLARMENTE LE RICHIESTE DEL CLIENT COSI CHE IL CONTROLLER VA A COLLEGARSI DIRETTAMENTE AL REPOSITORY DI AUTHOR


ABBIAMO CREATO U METODO CHE RESTITUISCE UNA LIST DI AUTORI, UTILIZZANDO PERCIO IL REPOSITORY:
@AUTOWIRED E AUTHORREPOSITORY REPOSITORY

@controller PER IDENTIFICARLA COME BEAN(STEREOTYPE)
@responsebody indica che il valore restituito deve essere considerato come il corpo della risposta http E NON COME UNA VISTA DA RISOLVERE.
USIAMO UN METODO FINDALL DELL INTERFACCIA CRUDREPOSITORY, QUESTO PERO RESTITUISCE UN ITERABLE CHE NON E CONVERTIBILE IN UNA LISTA, ALLORA DOVREMO UTILIZZARE UNA NUOVA INTERFACCIA LISTCRUDREPOSITORY CHE HA IL METODO FINDALL, QUESTA E UNA NUOVA INTERFACCIA CHE SPECIALIZZA I REPO PER LE LIST(SOSTITUIRE TUTTI I REPO AFFINCHE ESTENDANO LISTCRUDREPOSITORY)


I CONTROLLER GESTISCONO RICHIESTE CLIENT, COSI CHE E NECESSARIA UNA NUOVA ANNOTATION:
    @RequestMapping(value = "/authors", method = RequestMethod.GET)

MAPPA LE RICHIESTE HTTP VERSO METODI SPECIFICI, INDICHIAMO A SPRING QUALE METODO DEVE ESSERE ESEGUITO IN BASE ALLA RICHIESTA RICEVUTO SU UN URL ATTRAVERSO UN URI SPECIFICO(URI,METODO): FUNZIONE HANDLER, PRIMO METODO API.

PUO ESSERE APPLICATA A LIVELLO DI CLASSE O DI METODO

CREO SCRIPT DI INSERIMENTO IN SQL PER TESTARE IL METODO GET APPENA CREATO
in folder .sql CREO INSERT.SQL CON DUE AUTORI

INSERT INTO authors (firstname, lastname, email)
value ("lollo", "micio", "lollo@micio.it");

INSERT INTO authors (firstname, lastname, email)
value ("fofo", "ciotti", "fofo@ciotti.it");

ESEGUO CON RUN ON ACTIVE

ADESSO PROVIAMO AD AVVIARE L APPLICAZIONE, RUNNO LA CLASSE APPLICATION
SI AVVIERA IL TOMCAT, IL FLUSSO ADESSO E IN MANO AI CONTROLLER

ADESSO CHE L APPLICAZIONE E RUNNATA HO MODO DI VEDERE UN INTERFACCIA SUL MIO LOCALHOST INPOSTATO, LA PORTA LA VEDO DA TERMINALE
http://localhost:8080/authors : CI RESTITUISCE UN JSON GRAZIE ALL AZIONE DI UN PARAMETRO DI REQUESTMAPPING CHE SI CHIAMA PRODUCEJSON NEL CONTROLLER.

CREO I CONTROLLER PER TUTTE LE CLASSI CON @AUTOWIRED DEI LORO REPOSITORI E CREO GLI HANDELER

@Controller
public class CommentController {

    @Autowired
    CommentRepository commentRepository;

    @RequestMapping(value = "/comments", method = RequestMethod.GET)
    public @ResponseBody List<Comment> getAllComments() {
        return commentRepository.findAll();
    }
}

@Controller
public class PostController {

    @Autowired
    PostRepository postRepository;

    @RequestMapping(value = "/posts", method = RequestMethod.GET)
    public @ResponseBody List<Post> getAllPosts() {
        return postRepository.findAll();
    }

}

ADESSO NELL INSERT CREO DEI POST


INSERT INTO posts (title, body, publish_date, author_id) SELECT 'primopost', 'body body body body0', null, id FROM authors where firstname= 'fofo' and lastname= 'ciotti';

INSERT INTO posts (title, body, publish_date, author_id) SELECT 'secondoopost', 'bodyyyy bodyyyy body body0', null, id FROM authors where firstname= 'fofo' and lastname= 'ciotti';

COSI COME ADESSO MI CREA UN LOOP PERCHE ADESSO AVVIENE UNA CHIAMATA CONTINUA PERCHE POSTS CHIAMA AUTHORS CONTINUAMENTE, AGGIUNGIAMO @JSONIGNOREPROPERTIES CHE FA SI CHE IN CASO IN SERIALIZZAZIONE NON VENGA RIPETUTO ANCHE IL JSON DELLA TABELLA COLLEGATA:
@JsonIgnoreProperties({ "author" })
 SOTTO TABLE NEL MODELLO POST

METTENDO IL JSONIGNORE SU TUTTA LA CLASSE DEL MODELLO NON HO ACCESSO AGLI AUTORI DA POST, PER FAR VEDERE GLI AUTORI DA POSTS DEVO AGGIUNGERE

@JsonIgnoreProperties({ "author" })
NEL MODELLO AUTHOR SOPRA LA RELAZIONE ONE TO MANY

@JsonIgnoreProperties({ "posts" })
NEL MODELLLO POST SOPRA LA RELAZIONE MANY TO ONE

ADESSO CORREGGERE ANCHE IL MODELLO COMMENT PER LA RELAZIONE CON I POST

@JsonIgnoreProperties({ "post" }) NELLA RELAZIONE IN POST

@JsonIgnoreProperties({ "comments" }) NELLA RELAZIONE IN COMMENT

NELL INSERT AGGIUNGERE DEI COMMENTI PER LA PROVA

INSERT INTO comments (email, body, date, post_id) SELECT 'primocomment', 'body body body body0', null, id FROM posts where title= 'primopost';

INSERT INTO comments (email, body, date, post_id) SELECT 'secondocommmeent', 'bodyyyy bodyyyy body body0', null, id FROM posts where title= 'primopost';


POSSIAMO ADESSO SISTEMARE I NOSTRI CONTROLLER IN QUANDO ABBIAMO ASSEGNATO, IN QUANTO PER OGNUNO CE UN SOLO METODO, UNA SOLA REQUEST, UNA MAPPING URI DIRETTAMENTE AL METODO, DOVREMMO RIPETERLA PER OGNI METODO NEL CONTROLLER: VOLENDO ASSEGNARE LO STESSO URI A DIVERSI METODI DELLO STESSO CONTROLLER DOBBIAMO DEFINIRE L URI DIRETTAMENTE ALLA CLASSE
@RequestMapping("/authors")
@RequestMapping("/posts")
@RequestMapping("/comments")
TOGLIENDOLO DALLA REQUEST MAPPING DEL METODO

POSSIAMO PASSARE UN PARAMETRO NELL URI, CATTURARLO NEL METODO API E RISPONDERE CON UNA COSA DI QUESTO PARAMETRO:
@GetMapping("{id}")
public @ResponseBody Author getAuthor(@PathVariable("id") Long id) {
    return authorRepository.findById(id).get();
}

findbyid lo ereditiamo da crudrepository ma RESTITUISCE UN OPTIONAL CHE PUO CONTENERE L OGGETTO SE PRESENTE O VUOTO SE NON E STATO TROVATO(GESTISCE VALORI CHE POTREBBERO ESSERE NULLI), E NECESSARIO CON UN OPTIONAL FAR SEGUIRE IL METODO .GET()
NELL URI ABBIAMO PASSATO IL PARAMETRO
@PATHBVARIABLE PASSIAMO UNA STRINGA CHE INDICA IL NOME DEL PARAMETRO INSERITO NELL URI CHE STIAMO PASSANDO, DOPO VA LA TIPOLOGIA DI QUESTO PARAMETRO

MIGLIORARE ANCORA I CONTROLLER COSI CHE I CONTROLLER FACCIANO SOLO RESTAPI
@RESTCONTROLLER
gestisce richieste che possono restituire risposte in json
INOLTRE PERMETTE DI OMETTE @RESPONSEBODY NEI METODI

ADESSO OGNI METODO POSSIAMO SOSTITUIRE LE REQUEST CON LE ANNOTATION CON I SINGOLI METODI


CREARE LA POST, PER CREARE UN ELEMENTO NEL DB
CREIAMO L HANDLER
@PostMapping
public Author createAuthor(@RequestBody Author author) {
    return authorRepository.save(author);
}

IN QUESTO METODO RITORNIAMO UN OGGETTO AUTHOR E CON SAVE(AUTHOR) CHE E UN METODO DEL CRUDREPOSITORY POSSIAMO SALVARLO NEL DB (STIAMO FACENDO SEMPRE TRAMITE REPOSITORY PERCHE IL SERVICE NSE SA DO STANNOOOOOOOO)
AUTHOR ARRIVA SOLO COME PARAMTRO, QUESTO OGGETTO E IL RISULTATO DI UNA TRASFORMAZIONE DA UNA STRINGA E GRAZIE A @REQUESTBODY LA STRINGA SI TRASFORMA IN OGGETTO(DESERIALIZZAZIONE DA STRINGA AD OGGETTO, LA STRINGA PROVIENE DA UN JSON DI DEFAULT, SE NON RICEVIAMO UNO DIVERSO DA JSON DOBBIAMO DEFINIRE IL CONSUMES = APPLICATION)

POSTMAN TOOL PER TESTARE IN LATO FE I METODI API 

SPECIFICO IL TIPO DI CHIAMATA E INCOLLO L URL
TEST UNA CHIAMATA GET E UNA POST PER IL METODO CREATE APPENA CREATO

CREO UN METODO PUT E UN DELETE PER TESTARE ANCHE QUESTE CHIAMATE

@PUTMAPPING E DELETEMAPPING

 @PutMapping("{id}")
public Author updateAuthor(@PathVariable("id") Long id, @RequestBody Author author) {
    author.setId(id);
    return authorRepository.save(author);
}
IN QUESTO CASO AVREMO NECESSITA SIA DI SPECIFICARE L ID CHE DI PASSARE UN NUOVO OGGETTO, IN QUANTO PRIMA TROVIAMO L'OGGETTO DA MODIFICARE POI LO SOSTITUIAMO CON UNO NUOVO, DOVREMO SOSTITUIRE OGNI CAMPO IN QUANTO CI DARA NULL SE NON MENZIONIAMO UN CAMPO, SE DIGITIAMO UN CAMPO MALE CI DARA ERRORE


 @DeleteMapping("{id}")
    public void deleteAuthor(@PathVariable("id") Long id) {
        if (authorRepository.existsById(id)) {
            Author author = authorRepository.findById(id).get();
            List<Post> authorPosts = author.getPosts();
            for (Post post : authorPosts) {
                post.setAuthor(null);
            }
            authorRepository.deleteById(id);
        } else {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "author not found");
        }
    }

DELETE MOLTO SEMPLICE DOBBIAMO SOLO PASSARE IL PARAMETRO DELL OGGETTO CHE VOGLIAMO ELIMINARE E AGGIUNGERE UN CONTROLLO PER VEDERE SE QUESTO ESISTE O MENO e all interno di questo svincolare tutti i post a lui collegati( oggetti creati tramite una sua relazione) e poi eliminare l oggetto








 









