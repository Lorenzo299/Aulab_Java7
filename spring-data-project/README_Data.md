SPRING DATA

SEMPLIFICA L ACCESSO AI DATI FORNENDO UN INTERFACCIA UNIFICATA E UTILIZZA LO STANDARD JPA JAVA PERSISTANCE API, SPRING DATA E IN GRADO DI INTERAGIRE CON QUALUNQUE DB (SQL E NOSQL)

CONCETTO CHIAVE E IL REPOSITORY, CHE PUO ESSERE ASSOCIATO A QUALSIASI ENTITATA DI DATI. JPAREPOSITORY E LE SUE SOTTOCLASSI E LA TIPIZZAZIONE DI REPOSITORY CHE USEREMO, CHE CI PERMETTERA DI SCRIVERE CODICE SOLO QUANDO E NECESSARIO(CONVENTION OVER CONFIGURATION)

JPA E UNA LIBRERIA CHE INTRODUCE LA JPQL JAVA PERSISTANCE QUERY LANGUAGE, UN ASTRAZIONE CHE PERMETTE DI FARE QUERY SU UN DB TRAMITE IL MODELLO DELL ENTITA CORRISPONDENTE, SENZA SCRIVERLA IN SQL.
JPA E UN INSIME DI INTERFACCE COSI CHE NON ESISTONO VERE E PROPRIE IMPLEMENTAZIONI, QUESTE SARANNO DATE DALLA LIBRERIA HIBERNATE CHE FORNISCE UN ORM.
LA CONNESSIONE CON JDBC ( JAVA DB CONNECTION) SARA FATTA IN AUTOMATICO GRAZIE AD UNA SEMPLICE DIPENDENZA
JPA PERCIO NON E UNA IMPLEMENTAZIONE CONCRETA, MA UNA SPECIFICA DA SEGUIRE PER IMPLEMENTARE CLASSI GRAZIE A HIBERNATE.
HIBERNATE E UN IMPLEMENTAZIONE CHE SEGUE LE SPECIFICHE DI JPA

ORM OBJECT RELATIONAL MAPPER SERVE PER LA GESTIONE DELLA PERSISTENZA DEI DATI NEL DB ATTRAVERSO GLI OGGETTI. L ORM MAPPA GLI ATTRIBUTI DELL OGGETTO CON LE COLONNE DELLA TABELLA UNA VOLTA CHE ABBIAMO DETTO AL MODELLO QUALE TABELLA E LA SUA CORRISPONDENTE, SE SI MANTIENE LA STESSA NOMENCLATURA E POSSIBILE CHE ORM RIESCA A CONVERTIRE IL MODELLO CON LA TABELLA CORRISPONDENTE.

PROGETTO BLOG CON UN DATABASE CEH SEGUE IL DIAGRAMMA ENTITY RELATIONSHIP DIAGRAM (EER): RAPPRESENTA L ENTITA DEL SISTEMA E LE RELAZIONI TRA LORO

CREA PROGETTO
SPRING INITIALIZER  CREATE MAVEN
ULTIMA VERSIONE NON SNAPSHOT
JAVA
GRPUP ID (IT.AULAB)
NOME PACCHETTO
JAR
VERSIONE JAVA
DIPENDENZE NECESSARIE (JPA SPRING DATA, MYSQL DRIVER, SPRING BOOT DEVTOOLS, SPRING WEB)
SALVA NEL FOLDER E OPEN DALLA NOTIFICA

CREO DATABASE MYSQL
LO COLLEGO CON MYSQLTOOLS(SOTTO EXTENSION, TEST,..)
MYSQL.. DEVO DARE UN NOME A PIACERE E POI SCRIVERE ESATTAMENT QUELLO DEL DATABASE

CREO FOLDER .SQL E IN QUETSA
-CREATE.SQL E QUI POSSO SCRIVERE CODICE IN MYSQL PER LA CREAZIONE DELLE TABELLE
create table authors (
    id BIGINT auto_increment PRIMARY KEY,
    firstname VARCHAR(100),
    lastname VARCHAR(100),
    email VARCHAR(100)
);
create table posts (
    id BIGINT auto_increment PRIMARY KEY,
    title VARCHAR(100) not NULL,
    body VARCHAR(100) not NULL,
    publish_date CHAR(8),
    author_id BIGINT,
    FOREIGN KEY (author_id) REFERENCES authors(id)
);

create table comments (
    id BIGINT auto_increment PRIMARY KEY,
    email VARCHAR(100) not NULL,
    body VARCHAR(200) not NULL,
    date CHAR (8),
    post_id BIGINT,
    FOREIGN KEY (post_id) REFERENCES posts(id)
);
-RUNNO PER VEDERE SE CI SONO ERRORI
-DROP.SQL E FACCIO DROP TABLE PER OGNI TAB IN ORDINE DI SVINCOLO DELLE CHIAVI(PRIMA L ULTIMA): drop table comments; drop table posts; drop table authors;


APPLICATION PROPERTIES 
QUI AGGIUNGO LE CONFIGURAZIONI PER CREARE IL JDBC TEMPLATE, JPA USA IL JDBC TEMPLATE MA DOBBIAMO CREARLO: CONNECTION STRING, DRIVER, USERNAME, PASSWORD

spring.datasource.url=jdbc:mysql://localhost:3306/springBlogDatabase
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

ADESSO IL PROGETTO E REALMENTE COLLEGATO AL DATABASE

ENTITY MANAGER: INTERFACCIA NECESSARIA CHE INTERAGISCE CON IL MODELLO(ENTITA) DEI DATI.
NEI MODELLI DEFINIAMO LE CARATTERISTICHE DEFLI OGGETTI CHE SARANNO RIFLESSE NELLE TAB DEL DB, AGGIUNGENDO FUNZ UTILI COME LE RELAZIONI TRA I MODELLI STESSI.
AUTHORS AVRA UNA RELAZIONE 1TOMANY CON POSTS E QUANDO DICHIAREREMO IL MODELLO AUTORE DAREMO UNA PROPRIETA POSTS CHE RESTITUIRA I POST DELL AUTORE, GRAZIE ALLE ANOOTATION.
L ENTITY MANAGER PERMETTE DI ESEGUIRE OPERAZIONI SULLA PERSISTENZA DEI DATI (CRUD).

USEREMO HIBERNATE COME IMPLEMENTAZIONE DEL JPA

MODELS FOLDER
CREIAMO AUTHOR : @ENTITY INDICA ALLA JPA CHE QUESTA CLASSE HA UNA TABELLA DI RIFERIMENTO NEL DB, @TABLE(NAME = "AUTHORS") NOME DELLA TABELLA NECESSARIO!!

DEFINIAMO ATTRIBUTI

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
GENERATED VALUE PERMETTE DI DIRE CHE IL VALORE IN DB DI QUESTO SARA GENERATO DALLA JPA E CON LA STRATEGY GLI DICIAMO IN CHE MODO(IDENTITY PER ID, AUTO IL FW LO DEDUCE, SEQUENCE CREA UNA SEQUENZA, UUID ID ESADECIMALE)

CREO UN ATTRIBUTO PER OGNI COLONNA DELLA TAB
SE IL NOME DELL ATTRIBUTO E UGAULE ALLA COLONNA NON CE BISOGNO DI DIRE NULLA, SE GLI ATTRIBUTI SONO DIVERSI CON LA COLONNA DOBBIAMO INSERIRE UNA SPECIFICA ANNOTATION @COLUMN 
CON QUESTA ANNOTATION POSSIAMO DEFINIRE NUOVE PROPRIETA COME POTER SPECIFICARE SE E NULLABLE O UNIQUE

@Column(name = "firstname", nullable = true)
private String name;
@Column(name = "lastname", nullable = true)
private String surname;
@Column(nullable = false, unique = true)
private String email;

EMAIL NON PUO ESSERE NULL E DEVE ESSERE UNICO

COMPLETA CON GETTER E SETTER E UN COSTR VUOTO

CREO POST

@Entity
@Table(name = "posts")
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String title;
    @Column(nullable = false, length = 100)
    private String body;
    @Column(nullable = true, length = 8)
    private String publishDate;

}

PUBLISHDATE IN DB E PUBLISH_DATE MA VA BENE COMUNQUE
QUI DOBBIAMO AGGIUNGERE LA RELAZIONE CON LA TAB AUTHORS (CLASSE AUTHOR)

@ManyToOne
@JoinColumn(name = "author_id")
private Author author;

GETTER SETTER E COSTRUTTORE VUOTO

CREO COMMENT

@Column(nullable = false, length = 100)
    private String title;
    @Column(nullable = false, length = 200)
    private String body;
    @Column(nullable = true, length = 8)
    private String publishDate;

    @ManyToOne
    @JoinColumn(name="post_id", nullable = false)
    private Post post;

GETTER E SETTER


ADESSO DA UN AUTORE VOGLIO ACCEDERE AI SUOI POST E DAI POST AI SUOI COMMENTI

in author
@OneToMany(mappedBy = "author")
private List<Post> posts = new ArrayList<Post>();

SARA UNA LISTA DI POST, MAPPERDBY SI RIFERISCE A QUALE ATTRIBUTO STA ACENDO IL COLLEGAMENTO(L ATTRIBUTO DELLA CLASSE POST MANYTOONE AUTHOR)
CREAIAMO UN ARRAYLIST VOUTO COSI CHE IN CASO DI DROP NON ABBIAMO NULL

UGUALE IN POST
@OneToMany(mappedBy = "post")
    private List<Comment> comments = new ArrayList<Comment>();


GETTER E SETTER SEMPRE

ONE TO MANY E MANY TO MANY HANNO I PARAMETRI PERCHE COSI QUANDO SI FA LA QUERY SI FA LA QUERY DI TUTTE LE RISORSE DISPONIBILE, RICHIAMANDO ANCHE L OGETTO NELLA CLASSE COLLEGATA


CREARE FOLDER REPOSITORIES, IL FULCRO DI SPRING DATA: CRUD REPOSITORY.

INTERFACCIA CRUDREPOSITORY (estesa non implementata): SEMPLIFICA L ACCESSO E LA GESTIONE DI DATI IN UN DB CON IL CRUD PERCHE FORNISCE METODI PREDEFINITI CHE HANNO BISOGNO DI 2 DATI: LA CLASSE SU CUI AGISCE, E LA tipologia della sua PRIMARYKEY:

CREO INTERFACCIA PER OGNI CLASSE CHE RAPPRESENTA UNA TABELLA NEL DB CHE ESTENDE CRUDREPOSITORY<classe, tipodatoId>:

ESTENDENDO A CRUDREPOSITORY VENGONO IMPLEMENTATI TUTTI I METODI DI QUESTA CHE FACILITANO LE OPERAZIONI DI CRUD, CRUDREPO VIENE GESTITA COME UN BEAN PERCIO NON HA @COMPONENT, SI USA EXTENDS QUANDO UN INTERFACCIA IMPLEMENTA UN ALTRA INTERFACCIA


DERIVED QUERY: INTERFACCE CHE PERMETTONO DI EFFETTUARE OPERAZIONI SUL DATABASE AD ESEMPIO DELLE QUERY CHE FILTRANO I RISULTATI SU DEGLI ATTRIBUTI IN BASE A DEI FILTRI CHE GLI DICIAMO, QUESTO AVVIENE RISPETTANDO ALCUNE CONVENZIONI

NEI REPOSITORY ANDREMO SOLO A SPECIFICARE LE FIRME DEI METODI (NOME E PARAMETRI CHE ACCETTANO). SI POSSONO USARE AD ESEMPIO PAROLE CHIAVE COME FIND PER INDICARE L AZIONE CHE QUELLA FUNZ DEVE COMPIERE (FINDBYNAME).

public interface AuthorRepository extends CrudRepository<Author, Long> {
    List<Author> findByName(String name);

    List<Author> findBySurname(String surname);

    List<Author> findByNameAndSurname(String name, String surname);
}

FINDBYNAME/SURNAME.. ECC E UNA SINTASSI NECESSARIA PER FAR APPLICARE IL METODO E QUELLO CHE CE DOPO FINDBY DEVE ESSERE NECESSARIAMENTE UGUALE ALL ATTRIBUTO SU CUI E RIFERITA LA FUNZIONE, OVVIAMENTE I PARAMETRI FORMALI COME VOGLIO

TESTIAMO: USANDO UNO STRUMENTO DI SPRING CHE VA CONFIGURATO IN PROPERTIES CHE PERMETTERA A HIBERNATE DI EFFETTUARE LE QUERY. 

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

PER TESTARE ADESSO DOBBIAMO SPECIFICARE LA CLASSE TEST :
@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
class SpringDataProjectApplicationTests {
	@Autowired
	AuthorRepository authorRepository;

	@BeforeEach
	void load() {
		Author a1 = new Author();
		a1.setName("lollo");
		a1.setSurname("micio");
		a1.setEmail("lollo@micio.it");
		authorRepository.save(a1);
	}

	@Test
	void contextLoads() {
	}

}

@DATAJPATEST DICIAMO CHE VOGLIAMO SOLO CARICARE E TESTARE LE JPA ,NON TUTTO APLLICATION CONTEXT
@AUTOCONFIGURETESTDATABASE DICIAMO CHE USIAMO IL DB ATTUALE E NON UNO DI TEST
@BEFOREEACH SIGNIFICA CHE QUESTO METODO VIENE ESEGUITO PRIMA DEI TEST @TEST, USATO PE RIMPOSTARE LO STATO INIZIALE

NEL METODO LOAD CREIAMO UN AUTORE, DA DEGLI ATTRIBUTI E FA UNA SAVE() NEL DB COSI CHE POSSIAMO TESTARE

POI CREIMAMO IL METODO PER IL TEST 
@Test
	void findByName() {
		assertThat(authorRepository.findByName("lollo")).extracting("name").containsOnly("lollo");
	}

IMPORTANDO A MANO
import static org.assertj.core.api.Assertions.*;

QUESTO TEST FA SI CHE SI CONTROLLI LA FUNZIONE FINDBYNAME RESTIUISCA UNA LISTA CHE CONTENGA SOLO IL NOME DEFINITO

LANCIO IL TEST CON LA FRECCETTA A LATO DEL METODO


NON DOBBIAMO USARE QUERY AUTOGENERATO CON DERIVED QUERY

@QUERY(TIPOLOGIAQUERY) 
LE TIPOLOGIE DI QUERY SONO NATIVE E NON NATIVE

NATIVA 
NELLA REPOSITORY sotto le firme dei metodi
 @Query(value = "SELECT * FROM authors a WHERE a.firstname = 'lollo'", nativeQuery = true)
    List<Author> authorsWithSameName();

E TESTIAMO CON IL NUOVO METODO
@Test
	void sameNameAuthor() {
		assertThat(authorRepository.authorsWithSameName()).extracting("name").containsOnly("lollo");
	}

NON NATIVA USA GLI OGGETTI NELLA SUA SINTASSI
@Query(value = "SELECT a FROM Author a WHERE a.name = 'lollo'")
    List<Author> authorsWithSameNameNonNative();

E IL TEST SARA:

@Test
	void sameNameAuthorNonNative() {
		assertThat(authorRepository.authorsWithSameNameNonNative()).extracting("name").containsOnly("lollo");
	}













